function [A,ph,lo_A,lo_ph] = correction_transducer_sim(tab,tran,f,A,ph,u_A,u_ph,opt,Zx)% TWM: This function calculates loading effect of the transducer by the cable(s)/digitizer input% impedance. It is inverse function for the 'correction_transducer_loading()'.  % It will take the transducer input levels, correction data% describing the cable(s), terminal(s) and input admittance of the digitizer(s) and will return% the voltage(s) at the digitizer input. It can calculate correction for both single-ended% and differentially connected transducers (including the leakage effects via low-side connection).% It can also simulate randomization of the correction data by the assigned uncertainty.% %%    %% Usage:%% [] = correction_transducer_sim('test')%   - run function selftest%% Parameters:%   tab     - TWM-style correction tables with items:%             tr_gain - 2D table (freq+rms axes) of tran. absolute gain values (in/out)%             tr_phi - 2D table (freq+rms axes) of tran. phase shifts (in/out) [rad]%             tr_Zca - freq dep. of output terminals series Z (Rs+Ls format)              %             tr_Yca - freq dep. of output terminals shunting Y (Cp+D format)%             tr_Zcal - freq dep. of low-side output terminal series Z (Rs+Ls format)%             tr_Zcam - freq dep. of mutual inductance of output terminals%             adc_Yin - freq dep. of digitizer input admittance (Cp+Gp format)%             lo_adc_Yin - freq dep. of digigitizer low-side channel input%                          admittance (Cp+Gp format), differential mode only%             Zcb - freq dep. of cable series Z (Rs+Ls format)%             Ycb - freq dep. of cable shunting Y (Cp+D format)%             tr_Zlo - freq dep. of RVD's low side resistor Z (Rp+Cp format)%                      note: not used for shunts%   tran    - transducer type {'rvd' or 'shunt'}%   f       - vector of frequencies for which to calculate the correction [Hz]%   A       - vector of amplitudes at the digitizer input [V]%   ph      - vector of phase angles at the digitizer input [rad]%   u_A     - vector of abs. uncertainties of 'A' %   u_ph    - vector of abs. uncertainties of 'ph'%   opt     - options string: 'rand' to add randomized uncertainty to each input%             and correction table value%   Zx      - residual impedance for the differential mode%             note: only scalar allowed!%% Returns:%   A     - calculated digitizer input amplitudes (high-side) [V]%   ph    - calculated digitizer input phase shifts (high-side) [rad]%   lo_A  - low-side complement of 'A' (differential mode only)%   lo_ph - low-side complement of 'ph' (differential mode only)%%%% The correction applies following equivalent circuit (single-ended mode):%%  in (RVD)%  o-------+%          |%         +++%         | | Zhi%         | |%         +++ Zca/2      Zca/2      Zcb/2      Zcb/2%  in      |  +----+     +----+     +----+     +----+          out%  o-------+--+    +--+--+    +--o--+    +--+--+    +--o--+-----o%  (shunt) |  +----+  |  +----+     +----+  |  +----+     |%         +++        +++                   +++           +++%         | |        | |                   | |           | |%         | | Zlo    | | Yca               | | Ycb       | | Yin%         +++        +++                   +++           +++%  0V      |          |                     |             |     0V%  o-------+----------+----------o----------+----------o--+-----o%%  ^                             ^                     ^        ^%  |                             |                     |        |%  +-------- TRANSDUCER ---------+------ CABLE --------+- ADC --+%% The correction consists of 3 components:%  a) The transducer (RVD or shunt). When shunt, the Zhi nor Zlo are not%     required as the Zlo can be expressed from tr_gain and tr_phi.%     Part of the tran. definition is also its output terminals modeled %     as transmission line Zca/2-Yca-Zca/2.%  b) Second part is optional cable from Zcb/2-Ycb-Zcb/2.%  c) Last part is the internal shunting admittance of the digitizer's channel.%% The algorithm calculates the transfer in 3 steps:%  1) Unload the transducer from the Zca-Yca load.%  2) Calculate effect of the cable and digitizer to the impedance Zlo.%  3) Calculate complex transfer from V(Zlo) to V(out).%  4) It calculates the digitizer input voltage.%% Note the 'Zca' in the diagram is defined as: (Zca + Zcal - 2*Zcam).% If the 'Zcal' and 'Zcam' are not defined, they are ignored.    % % %%% The correction applies following equivalent circuit (differential mode):%%  in (RVD)%  o-------+%          |%         +++%         | | Zhi                   %         | |          %         +++ Zca/2      Zca/2       Zcb/2      Zcb/2%  in      |  +----+     +----+      +----+     +----+          %  o-------+--+    +--+--+    +--o---+    +--+--+    +--o---+---o u%  (shunt) |  +----+  |  +----+      +----+  |  +----+      |%          |          |      ^              +++            +++%         +++        +++      \             | |            | |%         | |        | | Yca   | M          | | Ycb        | | Yin%         | |        | |       |            +++            +++%         +++        +++      /              |              |%      Zlo |          |      v     +---------+----------o---+---o gnd_u%  0V      |  +----+  |  +----+    | +----+     +----+%  o-------+--+    +--+--+    +--o---+    +--+--+    +--o---+---o u_lo%             +----+     +----+    | +----+  |  +----+      |%             Zcal/2     Zcal/2    | Zcb/2  +++  Zcb/2     +++%                                  |        | |            | |%                                  |        | | Ycb        | | lo_Yin%                                  |        +++            +++%                                  |         |              |%                                  +---------+----------o---+---o gnd_u_lo%                                  |%                                 +++                                %  ^                             ^                      ^       ^%  |                             |                      |       |%  +-------- TRANSDUCER ---------+------ CABLES --------+- ADC -+%% The correction consists of several sections:%  a) transducer with its terminals model (Zca, Zcal, Zcam, Yca)%  b) cables to the digitizers (Zcb, Ycb)%  c) digitizer shunting admittances Yin, lo_Yin%% 1) The solver first simplifies the cables+digitizers to following:%  %  in (RVD)%  o-------+%          |%  +--+   +++%  |  |   | | Zhi                       %  |  |   | |                           Uhi%         +++ Zca/2      Zca/2        ------->                %  in      |  +----+     +----+        +----+                     %  o-------+--+    +--+--+    +--o-----+    +---+%  (shunt) |  +----+  |  +----+        +----+   |                %  |  |    |          |  *   ^          Zih     |                %  |  |   +++  +--+  +++      \         ----+   |                %  |I1|   | |  |I2|  | | Yca   | Zcam    I3 |   |                     %  |  |   | |  |  v  | |       |        <---+   |                %  |  |   +++  +-    +++      /         Ulo     |              %      Zlo |          |  *   v        ------->  |                         %  0V      |  +----+  |  +----+        +----+   |         %  o-------+--+    +--+--+    +--o-----+    +---+%          |  +----+     +----+        +----+   |              %  |  |   +++ Zcal/2     Zcal/2         Zil     |               %  |  v   | |                    -----------+   |               %  |      | |                         I4    |   |                      %         +++ Zx (unknown)       <----------+   |             %  GND     |                                    |              %  o-------+------------------------------------+%  ^       |                     ^              ^%  |      +++                    |              |%  +-------- TRANSDUCER ---------+-- CABLES ----+%                                     +ADC% 2) Unload the transducer from the Zca-Zcal-Yca+Zcam load.% 3) It solves the circuit mesh by loop-current method to obtain currents I1 and I2.% 4) It calculates the digitizer input voltages Ulo and Uhi.%%% This is part of the TWM - TracePQM WattMeter (https://github.com/smaslan/TWM).% (c) 2018, Stanislav Maslan, smaslan@cmi.cz% The script is distributed under MIT license, https://opensource.org/licenses/MIT.                %    if ischar(tab) && strcmpi(tab,'test')        % --- run self-test:        correction_transducer_sim_test();                A = [];        ph = [];        lo_A = [];        lo_ph = [];        return            end    % interpolation mode:    int_mode = 'pchip';    % differential tran. mode?    is_diff = nargin >= 9;        % tran. is RVD?    is_rvd = strcmpi(tran,'rvd');        % randomize quantities?    is_rand = strcmpi(opt,'rand');        % convert inputs to vertical:    org_orient = size(f); % remember original orientation    F = numel(f);    f = f(:);    A = A(:);    ph = ph(:);    u_A = u_A(:);    u_ph = u_ph(:);        % used frequency range:    f_min = min(f);    f_max = max(f);        % make list of involved correction tables:    tlist = {tab.tr_gain,tab.tr_phi,tab.tr_Zca,tab.tr_Yca,tab.Zcb,tab.Ycb,tab.adc_Yin};    if is_diff                tlist = {tlist{:},tab.lo_adc_Yin,tab.tr_Zcal,tab.tr_Zcam};    end    if is_rvd        tlist = {tlist{:},tab.tr_Zlo};    end        % merge axes of the tables to common range:    % note: just to find available range of freq.    [tlist,rms,fx] = correction_expand_tables(tlist,'none');    clear tlist;        if ~isempty(fx) && (f_min < min(fx) || f_max > max(fx))         error('Transducer loading error simulator: Insufficient range of the correction tables!');    end        % calc. input RMS estimate:    rms = sum(0.5*A.^2).^0.5;        % tran. gain/phase:    tr_gain = correction_interp_table(tab.tr_gain,rms,f,int_mode);    tr_phi =  correction_interp_table(tab.tr_phi,rms,f,int_mode);    trg = tr_gain.gain + tr_gain.u_gain.*randn(F,1)*is_rand;    trp = tr_phi.phi + tr_phi.u_phi.*randn(F,1)*is_rand;    tr = trg.*exp(j*trp);        % get RVD's low side impedance:    if is_rvd        Zlo = correction_interp_table(tab.tr_Zlo,[],f,int_mode);        Zlo = CpRp2Z(f,Zlo.Cp + Zlo.u_Cp.*randn(F,1)*is_rand,Zlo.Rp + Zlo.u_Rp.*randn(F,1)*is_rand,0,0);        end        % high-side terminal impedance:    Zca = correction_interp_table(tab.tr_Zca,[],f,int_mode);    Zca = LsRs2Z(f,Zca.Ls + Zca.u_Ls.*randn(F,1)*is_rand,Zca.Rs + Zca.u_Rs.*randn(F,1)*is_rand,0,0);        % low-side terminal impedance:    Zcal = correction_interp_table(tab.tr_Zcal,[],f,int_mode);    Zcal = LsRs2Z(f,Zcal.Ls + Zcal.u_Ls.*randn(F,1)*is_rand,Zcal.Rs + Zcal.u_Rs.*randn(F,1)*is_rand,0,0);        % mutual terminal impedance:    Zcam = correction_interp_table(tab.tr_Zcam,[],f,int_mode);    Zcam = j*2*pi*f.*(Zcam.M + Zcam.u_M.*rand(F,1)*is_rand);        % terminals shunting admittance:    Yca = correction_interp_table(tab.tr_Yca,[],f,int_mode);    Yca = CpD2Y(f,Yca.Cp + Yca.u_Cp.*randn(F,1)*is_rand,Yca.D + Yca.u_D.*randn(F,1)*is_rand,0,0);        % output cable impedance:    Zcb = correction_interp_table(tab.Zcb,[],f,int_mode);    Zcb = LsRs2Z(f,Zcb.Ls + Zcb.u_Ls.*randn(F,1)*is_rand,Zcb.Rs + Zcb.u_Rs.*randn(F,1)*is_rand,0,0);        % output cable shunting admittance:    Ycb = correction_interp_table(tab.Ycb,[],f,int_mode);    Ycb = CpD2Y(f,Ycb.Cp + Ycb.u_Cp.*randn(F,1)*is_rand,Ycb.D + Ycb.u_D.*randn(F,1)*is_rand,0,0);        % ADC input admittance:    Yin = correction_interp_table(tab.adc_Yin,[],f,int_mode);    Yin = CpGp2Y(f,Yin.Cp + Yin.u_Cp.*randn(F,1)*is_rand,Yin.Gp + Yin.u_Gp.*randn(F,1)*is_rand,0,0);        % convert input levels to complex form:    A = (A + u_A.*randn(F,1)*is_rand).*exp(j*(ph + u_ph.*randn(F,1)*is_rand));            % --- unload transducer:        % effective terminals impedance:    Zca_ef = Zca + Zcal;        % transfer of the terminals 0.5*Zca-0.5*Zcal-Yca (in/out):    k_te = (Yca.*Zca_ef + 2)./2;        % update tfer:    tr = tr./k_te;        if ~is_rvd        % for shunt, estimate its impedance:        Zlo = 1./tr;    end        % actual internal Zlo impedance:    Zlo_int = 1./(1./(Zlo - 0.5*Zca_ef) - Yca) - 0.5*Zca_ef;        % effective low-side impedance with effect of the terminals shunting admittance:                Zlo_ef = 1./(1./Zlo_int + 1./(1./Yca + 0.5*Zca_ef));            if is_rvd        % -- RVD:                % high-side impedance:                Zhi = Zlo_ef.*(tr - 1);                        % calculate loaded transfer (in/out):        tr = (Zlo_ef + Zhi)./Zlo_ef;                % continue with the corrected low-side impedance:          Zlo = Zlo_int;            else        % -- SHUNT:                % default high-side RVD impedance (needed for the solver):        Zhi = 1e-15;                % subtract admittance of the connector (0.5*Zca-Yca)        Zlo = 1./(1./Zlo - 1./(0.5*Zca_ef + 1./Yca));        end                      if is_diff        % =====================================        % ========= DIFFERENTIAL MODE =========        % =====================================                % ADC input admittance:        Yinl = correction_interp_table(tab.lo_adc_Yin,[],f,int_mode);        Yinl = CpGp2Y(f,Yinl.Cp + Yinl.u_Cp.*randn(F,1)*is_rand,Yinl.Gp + Yinl.u_Gp.*randn(F,1)*is_rand,0,0);                % calculate transfer of the high-side cable to dig. input (in/out):        kih = (Yin.*Zcb + 2)./2;        Zih = 1./(1./(1./Yin + 0.5*Zcb) + Ycb);        kih = kih.*(Zih + 0.5*Zcb)./Zih; % complex cable to dig. transfer        Zih = Zih + 0.5*Zcb; % effective cable input impedance                         % calculate transfer of the low-side cable to dig. input (in/out):        kil = (Yinl.*Zcb + 2)./2;        Zil = 1./(1./(1./Yinl + 0.5*Zcb) + Ycb);        kil = kil.*(Zil + 0.5*Zcb)./Zil; % complex cable to dig. transfer        Zil = Zil + 0.5*Zcb; % effective cable input impedance                % calculate with nominal input voltage:        Ug = 1;                I3=((Ug.*(Yca.*(4.*Zil-4.*Zcam)+2.*Yca.*Zcal+4).*Zlo+Ug.*(Zcal.*(Yca.*(2.*Zil-2.*Zcam)+Yca.*Zca+4)+Yca.*Zca.*(2.*Zil-2.*Zcam)+4.*Zil-4.*Zcam+Yca.*Zcal.^2)).*Zx+Ug.*(Zcal.*(Yca.*(2.*Zil-2.*Zcam)+4)+4.*Zil+Yca.*Zcal.^2).*Zlo)./(((Zhi.*(Yca.*(4.*Zil+4.*Zih-8.*Zcam)+2.*Yca.*Zcal+2.*Yca.*Zca+4)+Zca.*(Yca.*(4.*Zil+2.*Zih-4.*Zcam)+4)+Yca.*(4.*Zih.*Zil-4.*Zcam.^2)+Zcal.*(2.*Yca.*Zih+2.*Yca.*Zca)+4.*Zih+Yca.*Zca.^2).*Zlo+Zcal.*(Zca.*(Yca.*(2.*Zil+2.*Zih-2.*Zcam)+4)+Yca.*(2.*Zih.*Zil-2.*Zcam.^2)+4.*Zih+Yca.*Zca.^2)+Zhi.*(Zcal.*(Yca.*(2.*Zil+2.*Zih-4.*Zcam)+2.*Yca.*Zca+4)+Zca.*(Yca.*(2.*Zil+2.*Zih-4.*Zcam)+4)+4.*Zil+4.*Zih-8.*Zcam+Yca.*Zcal.^2+Yca.*Zca.^2)+Zca.*(Yca.*(2.*Zih.*Zil-2.*Zcam.^2)+4.*Zil)+4.*Zih.*Zil+Yca.*Zca.^2.*Zil+Zcal.^2.*(Yca.*Zih+Yca.*Zca)-4.*Zcam.^2).*Zx+(Zhi.*(Zcal.*(Yca.*(2.*Zil+4.*Zih-4.*Zcam)+2.*Yca.*Zca+4)+Yca.*(4.*Zih.*Zil-4.*Zcam.^2)+2.*Yca.*Zca.*Zil+4.*Zil+Yca.*Zcal.^2)+Zcal.*(Zca.*(Yca.*(2.*Zil+2.*Zih-2.*Zcam)+4)+Yca.*(2.*Zih.*Zil-2.*Zcam.^2)+4.*Zih+Yca.*Zca.^2)+Zca.*(Yca.*(2.*Zih.*Zil-2.*Zcam.^2)+4.*Zil)+4.*Zih.*Zil+Yca.*Zca.^2.*Zil+Zcal.^2.*(Yca.*Zih+Yca.*Zca)-4.*Zcam.^2).*Zlo+Zhi.*(Zcal.*(Zca.*(Yca.*(2.*Zil+2.*Zih-2.*Zcam)+4)+Yca.*(2.*Zih.*Zil-2.*Zcam.^2)+4.*Zih+Yca.*Zca.^2)+Zca.*(Yca.*(2.*Zih.*Zil-2.*Zcam.^2)+4.*Zil)+4.*Zih.*Zil+Yca.*Zca.^2.*Zil+Zcal.^2.*(Yca.*Zih+Yca.*Zca)-4.*Zcam.^2));        I4=((Ug.*(Yca.*(4.*Zil+4.*Zih-8.*Zcam)+2.*Yca.*Zcal+2.*Yca.*Zca+4).*Zlo+Ug.*(Zcal.*(Yca.*(2.*Zil+2.*Zih-4.*Zcam)+2.*Yca.*Zca+4)+Zca.*(Yca.*(2.*Zil+2.*Zih-4.*Zcam)+4)+4.*Zil+4.*Zih-8.*Zcam+Yca.*Zcal.^2+Yca.*Zca.^2)).*Zx+Ug.*(Zcal.*(Yca.*(2.*Zil+2.*Zih-4.*Zcam)+Yca.*Zca+4)+4.*Zil-4.*Zcam+Yca.*Zcal.^2).*Zlo)./(((Zhi.*(Yca.*(4.*Zil+4.*Zih-8.*Zcam)+2.*Yca.*Zcal+2.*Yca.*Zca+4)+Zca.*(Yca.*(4.*Zil+2.*Zih-4.*Zcam)+4)+Yca.*(4.*Zih.*Zil-4.*Zcam.^2)+Zcal.*(2.*Yca.*Zih+2.*Yca.*Zca)+4.*Zih+Yca.*Zca.^2).*Zlo+Zcal.*(Zca.*(Yca.*(2.*Zil+2.*Zih-2.*Zcam)+4)+Yca.*(2.*Zih.*Zil-2.*Zcam.^2)+4.*Zih+Yca.*Zca.^2)+Zhi.*(Zcal.*(Yca.*(2.*Zil+2.*Zih-4.*Zcam)+2.*Yca.*Zca+4)+Zca.*(Yca.*(2.*Zil+2.*Zih-4.*Zcam)+4)+4.*Zil+4.*Zih-8.*Zcam+Yca.*Zcal.^2+Yca.*Zca.^2)+Zca.*(Yca.*(2.*Zih.*Zil-2.*Zcam.^2)+4.*Zil)+4.*Zih.*Zil+Yca.*Zca.^2.*Zil+Zcal.^2.*(Yca.*Zih+Yca.*Zca)-4.*Zcam.^2).*Zx+(Zhi.*(Zcal.*(Yca.*(2.*Zil+4.*Zih-4.*Zcam)+2.*Yca.*Zca+4)+Yca.*(4.*Zih.*Zil-4.*Zcam.^2)+2.*Yca.*Zca.*Zil+4.*Zil+Yca.*Zcal.^2)+Zcal.*(Zca.*(Yca.*(2.*Zil+2.*Zih-2.*Zcam)+4)+Yca.*(2.*Zih.*Zil-2.*Zcam.^2)+4.*Zih+Yca.*Zca.^2)+Zca.*(Yca.*(2.*Zih.*Zil-2.*Zcam.^2)+4.*Zil)+4.*Zih.*Zil+Yca.*Zca.^2.*Zil+Zcal.^2.*(Yca.*Zih+Yca.*Zca)-4.*Zcam.^2).*Zlo+Zhi.*(Zcal.*(Zca.*(Yca.*(2.*Zil+2.*Zih-2.*Zcam)+4)+Yca.*(2.*Zih.*Zil-2.*Zcam.^2)+4.*Zih+Yca.*Zca.^2)+Zca.*(Yca.*(2.*Zih.*Zil-2.*Zcam.^2)+4.*Zil)+4.*Zih.*Zil+Yca.*Zca.^2.*Zil+Zcal.^2.*(Yca.*Zih+Yca.*Zca)-4.*Zcam.^2));                I1=((2.*I4.*Yca.*Zlo+I4.*(Yca.*Zcal+Yca.*Zca+2)).*Zx+(I4.*Yca.*Zcal+2.*Ug.*Yca+2.*I3).*Zlo+Ug.*(Yca.*Zcal+Yca.*Zca+2))./((2.*Yca.*Zlo+Yca.*Zcal+Yca.*Zca+2).*Zx+(2.*Yca.*Zhi+Yca.*Zcal+Yca.*Zca+2).*Zlo+(Yca.*Zcal+Yca.*Zca+2).*Zhi);        I2=((2.*I4.*Yca.*Zlo+I4.*Yca.*Zcal+2.*I3).*Zx+(I4.*Yca.*Zcal+2.*Ug.*Yca+2.*I3).*Zlo+(I4.*Yca.*Zcal+2.*I3).*Zhi)./((2.*Yca.*Zlo+Yca.*Zcal+Yca.*Zca+2).*Zx+(2.*Yca.*Zhi+Yca.*Zcal+Yca.*Zca+2).*Zlo+(Yca.*Zcal+Yca.*Zca+2).*Zhi);                % calc scaling coefficient so the input level is 'A':        if is_rvd            % -- RVD:            kin = A./(Ug - (I1 - I4).*Zx);        else            % -- Shunt:            kin = A./(I1 - I4);        end                % get digitizer input voltages:        Y = Zih.*I3./kih.*kin;        lo_Y = Zil.*(I4 - I3)./kil.*kin;              else        % =====================================        % ========= SINGLE-ENDED MODE =========        % =====================================                % effective terminals series Z:        Zca = Zca + Zcal - 2*Zcam;                % cable-to-digitizer tfer (in/out):        k_in = (Yin.*Zcb + 2)/2;        % (ZL+0.5*Zcb)||Ycb (temp value):        Zx = 1./(Ycb + 1./(1./Yin + 0.5*Zcb));        % terminal-to-cable tfer (in/out):        k_cb = (0.5*Zcb + 0.5*Zca + Zx)./Zx;        % (0.5*Zca+0.5*Zcb+Zx)||Yca (temp value):        Zx = 1./(Yca + 1./(Zx + 0.5*Zca + 0.5*Zcb));        % tranfer transducer-terminal (in/out):        k_te = (Zx + 0.5*Zca)./Zx;                % calculate loaded low-side impedance:        Zlo_ef = 1./(1./Zlo + 1./(Zx + 0.5*Zca));                        % correct the transfer by the total load effect (out/in):        if is_rvd            % RVD:                              tr = Zlo_ef./(Zhi + Zlo_ef);                    else            % SHUNT:                      tr = Zlo_ef;                   end                % --- 3) Apply tfer of the whole terminal-cable-digitizer chain to the trans. tfer:            tr = tr./k_in./k_cb./k_te;                % --- 4) Calculate input level:        Y = A.*tr;                % default low-side return value (needed for Matlab):        lo_Y = Y.*0;                             end                 % convert output to polar form:    A = abs(Y);    ph = angle(Y);    lo_A = abs(lo_Y);    lo_ph = angle(lo_Y);        % restore original vector orientations:    A = reshape(A,org_orient);    ph = reshape(ph,org_orient);    lo_A = reshape(lo_A,org_orient);        lo_ph = reshape(lo_ph,org_orient);end% ---------------------------------------------------------------------------------------% Validation - this section contains functions used to validate the bloody algorithm function [] = correction_transducer_sim_test()% this is a test function that validates the loading algorithm by% calculating the same correction using different method - loop-currents        % define test configurations:        lab = {'full'};    F_list = [100000];    F_corr = 100;    id = 0;         for k = 1:numel(F_list)                F = F_list(k);            id = id + 1; % test 1:        cfg{id}.is_rvd = 1;        cfg{id}.is_diff = 0;                 cfg{id}.Rlo = 200;        cfg{id}.D = 10;        cfg{id}.F_corr = F_corr;        cfg{id}.F = F;        cfg{id}.label = ['SE, RVD test (' lab{k} ', ' int2str(F) ' spots)'];                id = id + 1; % test 2:        cfg{id}.is_rvd = 0;        cfg{id}.is_diff = 0;        cfg{id}.Rlo = 20;        cfg{id}.F_corr = F_corr;        cfg{id}.F = F;        cfg{id}.label = ['SE, shunt test (' lab{k} ', ' int2str(F) ' spots)'];                id = id + 1; % test 3:        cfg{id}.is_rvd = 1;        cfg{id}.is_diff = 1;        cfg{id}.Rlo = 200;        cfg{id}.D = 10;        cfg{id}.F_corr = F_corr;        cfg{id}.F = F;        cfg{id}.label = ['DIFF, RVD test (' lab{k} ', ' int2str(F) ' spots)'];                id = id + 1; % test 4:        cfg{id}.is_rvd = 0;        cfg{id}.is_diff = 1;        cfg{id}.Rlo = 20;        cfg{id}.F_corr = F_corr;        cfg{id}.F = F;        cfg{id}.label = ['DIFF, shunt test (' lab{k} ', ' int2str(F) ' spots)'];    end                for c = 1:numel(cfg)            % setup for current test:        s = cfg{c};                disp([s.label ' ...']);                % interpolation mode of the freq characteristics:        % note: must be identical to the one used by the main function        int_mode = 'pchip';            % frequency range of the simulation:        Fc = s.F_corr; % max correction spots        F = s.F; % data points (signal components to correct)        f = [];        f(:,1) = logspace(log10(10),log10(1e6),F);        fc = [];        %Fc = min(F,Fc);        fc(:,1) = logspace(log10(10),log10(1e6),Fc);        w = f*2*pi;                % randomized spectrum?        a_is_rand = isfield(s,'A_count');                % generate some spectrum:        A = ones(size(f));        ph = zeros(size(f));        u_A = 0*A;        u_ph = 0*ph;                % estimate rms value:        rms_v = sum(0.5*A.^2).^0.5;                    % rms range of the transd. transfers:        rms = [];        rms(1,:) = [0 1.1*rms_v 2*rms_v];        R = numel(rms);                % define low side impedance Cp+Rp:        Rlo = s.Rlo;        Clo = 50e-12;        Zlo = 1./(1/Rlo + j*w*Clo);                % nominal DC ratio of the transducer (in/out):        if s.is_rvd            D = s.D;        else            D = 0;        end                if s.is_rvd            % RVD high side parallel capacitance:            Chi = Clo/(D-1);                        % RVD calculate high side impedance:            Zhi = 1./(1/((D - 1)*Rlo) + j*w*Chi);        else            % no high-side resistor for shunt mode:            Zhi = repmat(1e-15,[F 1]);        end                % define low return path series impedance (diff mode only):        Rr = 1;        Lr = 5e-6;        Zx = Rr;% + j*w*Lr;                % define terminals impedances:        Ls_a = 1000e-9;        Rs_a = 50e-3;        Cp_a = 100e-12;        D_a = 0.01;        Zca = Rs_a + j*w*Ls_a;        Yca = w*Cp_a*(j + D_a);        % low-side:        Zcal = 1.2*Zca;        % mutual:        Ma = 300e-9;        Zcam = j*w*Ma;                        % define cable's impedance:        len_b = 0.5;        Ls_b = 250e-9;        Rs_b = 50e-3;        Cp_b = 105e-12;        D_b = 0.02;        Zcb = (Rs_b + j*w*Ls_b)*len_b;        Ycb = w*Cp_b*(j + D_b)*len_b;                % define digitizer input impedance Cp-Rp:        Cp_i = 50e-12;        Rp_i = 1e6;        Yin = 1./Rp_i + j*w*Cp_i;        Yinl = Yin;        Zin = 1./Yin;        Zinl = 1./Yinl;                % calculate effective value of the Zlo when loaded by 0.5*Zca-0.5*Zcal-Yca:        Zca_ef = Zca + Zcal;                    Zlo_ef = 1./(1./Zlo + 1./(1./Yca + 0.5*Zca_ef));                % transfer of the terminals 0.5*Zca-0.5*Zcal-Yca (in/out):        k_te = (Yca.*Zca_ef + 2)./2;                % calculate measurable low side impedance (measured via the output terminals):        % note: this is what user will measure when doing calibration        Zlo_meas = 1./(1./(Zlo + 0.5*Zca_ef) + Yca) + 0.5*Zca_ef;                                % calculate effective transfer from input to transducer terminals (in/out):        % note: this is what user will measure when doing calibration        if s.is_rvd            k_ef = (Zlo_ef + Zhi)./Zlo_ef.*k_te;        else            k_ef = 1./Zlo_ef.*k_te;        end                  % type of the transducer (control string for the corr. function):        tran = {'shunt','rvd'};        tran = tran{1 + s.is_rvd};                                % reinterpolate 'measured' transfer to correction freq spots:        g = abs(k_ef);            p = angle(k_ef);                    [gc,pc,u_gc,u_pc] = decim_corr_data(g,p,f,fc,int_mode);                % simulate transd. transfer and uncertainty (gain):        gc = repmat(gc,[1 R]);        u_gc = repmat(u_gc,[1 R]);        % simulate transd. transfer and uncertainty (phase):        pc = repmat(pc,[1 R]);        u_pc = repmat(u_pc,[1 R]);                             % remove some elements from the transd. tfer to emulate real correction data:        gc(end,end) = NaN;        u_gc(end,end) = NaN;                % build transd. tfer tables:                tab.tr_gain = correction_load_table({fc,rms,gc,u_gc},'rms',{'f','gain','u_gain'});        tab.tr_phi = correction_load_table({fc,rms,pc,u_pc},'rms',{'f','phi','u_phi'});        % build RVD's low-side impedance table:        [gc,pc,u_gc,u_pc] = decim_corr_data(g,p,f,fc,int_mode);                t_Rp = 1./real(1./Zlo_meas);        t_Cp = imag(1./Zlo_meas)./w;        if F > 1            t_Rp = interp1nan(f,t_Rp,fc,int_mode);            t_Cp = interp1nan(f,t_Cp,fc,int_mode);        else            t_Rp = repmat(t_Rp,size(fc));            t_Cp = repmat(t_Cp,size(fc));        end        tab.tr_Zlo = correction_load_table({fc,t_Rp,t_Cp,0*t_Rp,0*t_Cp},'',{'f','Rp','Cp','u_Rp','u_Cp'});                        % build terminal tables:            t_Rs = real(Zca);        t_Ls = imag(Zca)./w;        if F > 1            t_Rs = interp1nan(f,t_Rs,fc,'linear');            t_Ls = interp1nan(f,t_Ls,fc,'linear');        else            t_Rs = repmat(t_Rs,size(fc));            t_Ls = repmat(t_Ls,size(fc));        end        tab.tr_Zca = correction_load_table({fc,t_Rs,t_Ls,0*t_Rs,0*t_Ls},'',{'f','Rs','Ls','u_Rs','u_Ls'});        t_Cp = imag(Yca)./w;        t_D = real(Yca)./imag(Yca);        if F > 1            t_Cp = interp1nan(f,t_Cp,fc,'linear');            t_D = interp1nan(f,t_D,fc,'linear');        else            t_Cp = repmat(t_Cp,size(fc));            t_D = repmat(t_D,size(fc));                end        tab.tr_Yca = correction_load_table({fc,t_Cp,t_D,0*t_Cp,0*t_D},'',{'f','Cp','D','u_Cp','u_D'});        t_Rs = real(Zcal);        t_Ls = imag(Zcal)./w;        if F > 1            t_Rs = interp1nan(f,t_Rs,fc,'linear');            t_Ls = interp1nan(f,t_Ls,fc,'linear');        else            t_Rs = repmat(t_Rs,size(fc));            t_Ls = repmat(t_Ls,size(fc));                end          tab.tr_Zcal = correction_load_table({fc,t_Rs,t_Ls,0*t_Rs,0*t_Ls},'',{'f','Rs','Ls','u_Rs','u_Ls'}); % low-side        t_M = imag(Zcam)./w;        if F > 1            t_M = interp1nan(f,t_M,fc,'linear');        else            t_M = repmat(t_M,size(fc));        end        tab.tr_Zcam = correction_load_table({fc,t_M,0*t_M},'',{'f','M','u_M'}); % mutual                % build cable tables:        t_Rs = real(Zcb);        t_Ls = imag(Zcb)./w;        if F > 1            t_Rs = interp1nan(f,t_Rs,fc,'linear');            t_Ls = interp1nan(f,t_Ls,fc,'linear');        else            t_Rs = repmat(t_Rs,size(fc));            t_Ls = repmat(t_Ls,size(fc));        end        tab.Zcb = correction_load_table({fc,t_Rs,t_Ls,0*t_Rs,0*t_Ls},'',{'f','Rs','Ls','u_Rs','u_Ls'});        t_Cp = imag(Ycb)./w;        t_D = real(Ycb)./imag(Ycb);        if F > 1            t_Cp = interp1nan(f,t_Cp,fc,'linear');            t_D = interp1nan(f,t_D,fc,'linear');        else            t_Cp = repmat(t_Cp,size(fc));            t_D = repmat(t_D,size(fc));                end        tab.Ycb = correction_load_table({fc,t_Cp,t_D,0*t_Cp,0*t_Cp},'',{'f','Cp','D','u_Cp','u_D'});            % digitizer's input impedance:        t_Cp = imag(Yin)./w;        t_Gp = real(Yin);        if F > 1            t_Cp = interp1nan(f,t_Cp,fc,'linear');            t_Gp = interp1nan(f,t_Gp,fc,'linear');        else            t_Cp = repmat(t_Cp,size(fc));            t_Gp = repmat(t_Gp,size(fc));                end        tab.adc_Yin = correction_load_table({fc,t_Cp,t_Gp,0*t_Cp,0*t_Gp},'',{'f','Cp','Gp','u_Cp','u_Gp'});        t_Cp = imag(Yinl)./w;        t_Gp = real(Yinl);        if F > 1            t_Cp = interp1nan(f,t_Cp,fc,'linear');            t_Gp = interp1nan(f,t_Gp,fc,'linear');        else            t_Cp = repmat(t_Cp,size(fc));            t_Gp = repmat(t_Gp,size(fc));        end        tab.lo_adc_Yin = correction_load_table({fc,t_Cp,t_Gp,0*t_Cp,0*t_Gp},'',{'f','Cp','Gp','u_Cp','u_Gp'}); % low-side                                % --- now the fun part - exact forward solution ---                     if s.is_diff            % --- diff mode:                        % --- apply the loading correction to obtain original signal:                        tic();            [Aih,phih,Ail,phil] = correction_transducer_sim(tab,tran,f,A,ph,0*A,0*ph,'',Zx);            t_corr = toc();                                   [Ax,phx] = correction_transducer_loading(tab,tran,f,[], Aih,phih,0*Aih,0*phih, Ail,phil,0*Ail,0*phil);                    else            % --- single-ended mode:                        % --- apply the loading correction to obtain original signal:            tic();            [Ain,phin] = correction_transducer_sim(tab,tran,f,A,ph,0*A,0*ph,'');            t_corr = toc();                        [Ax,phx] = correction_transducer_loading(tab,tran,f,[], Ain,phin,0*Ain,0*phin);        end                        % calculate phase errors, discard those for zero amplitudes:        dph = (phx - ph);        dph(A == 0) = 0;                if isfield(s,'plot') && s.plot            figure                   semilogx(f,Ax - A)            hold on;            semilogx(f,+2*u_Ax,'r')            semilogx(f,-2*u_Ax,'r')            hold off;            title([s.label ' - gain']);                        figure            semilogx(f,dph)            hold on;            semilogx(f,+2*u_phx,'r')            semilogx(f,-2*u_phx,'r')            hold off;            title([s.label ' - phase']);        end                % define maximum deviations of the results from generated values (not including result uncertainty!):        u_Ax_lim = 1e-6*A;        u_phx_lim = 1e-6;                        % check correctness of the calculation            assert(~any(abs(Ax - A) > u_Ax_lim),[s.label ' gain not matching!']);        assert(~any(abs(dph) > u_phx_lim),[s.label ' phase not matching!']);                                disp(sprintf(' ... ok in %.2f s.',t_corr));        endend% ---------------------------------------------------------------------------------------% Impedance conversion routines% conversion of complex Z to Y and vice versafunction [Y,uY] = Z_inv(Z,uZ)  Rs = real(Z);  Xs = imag(Z);  uRs = real(uZ);  uXs = imag(uZ);    uGp = (4*Rs.^2.*Xs.^2.*uXs.^2+(Xs.^4-2*Rs.^2.*Xs.^2+Rs.^4).*uRs.^2).^0.5./(Xs.^8+4*Rs.^2.*Xs.^6+6*Rs.^4.*Xs.^4+4*Rs.^6.*Xs.^2+Rs.^8).^0.5;  %uGp =  (4*Rs.^2.*Xs.^2.*uXs.^2+(Xs.^4-2*Rs.^2.*Xs.^2+Rs.^4).*uRs.^2).^0.5./(Xs.^8+4*Rs.^2.*Xs.^6+6*Rs.^4.*Xs.^4+4*Rs.^6.*Xs.^2+Rs.^8).^0.5;  %uGp = ((4*Rs.^2.*Xs.^2.*uXs.^2)./(Xs.^2+Rs.^2).^4+(1./(Xs.^2+Rs.^2)-(2*Rs.^2)./(Xs.^2+Rs.^2).^2).^2.*uRs.^2).^0.5;    uBp = ((Xs.^4-2*Rs.^2.*Xs.^2+Rs.^4).*uXs.^2+4*Rs.^2.*Xs.^2.*uRs.^2).^0.5./(Xs.^8+4*Rs.^2.*Xs.^6+6*Rs.^4.*Xs.^4+4*Rs.^6.*Xs.^2+Rs.^8).^0.5;    Y = 1./Z;  if isreal(Y)    Y = complex(Y);  end  uY = complex(uGp,uBp);     end% conversion of Z-phi [Ohm-rad] scheme to complex Y scheme with uncertainty% note: it has been crippled by the bsxfun() for Matlab < 2016b - do not remove!function [Z,u_Z] = Zphi2Z(Z,phi,u_Z,u_phi)        % re: sqrt(Z^2*sin(phi)^2*u_phi^2+cos(phi)^2*u_Z^2):    % im: sqrt(g^2*cos(p)^2*u_p^2+sin(p)^2*u_g^2):    %u_Z = sqrt(Z.^2.*sin(phi).^2.*u_phi.^2 + cos(phi).^2.*u_Z.^2) + j*sqrt(Z.^2.*cos(phi).^2.*u_phi.^2 + sin(phi).^2.*u_Z.^2);    u_Z = (Z.^2.*sin(phi).^2.*u_phi.^2 + cos(phi).^2.*u_Z.^2).^0.5 + j*(Z.^2.*cos(phi).^2.*u_phi.^2 + sin(phi).^2.*u_Z.^2).^0.5;           % Z = Z*e(j*phi) [Ohm + jOhm]:    Z = Z.*exp(j*phi); end% conversion of complex Z to Z-phi [Ohm-rad] scheme% note: it has been crippled by the bsxfun() for Matlab < 2016b - do not remove!function [Z,phi,u_Z,u_phi] = Z2Zphi(Z,u_Z)     % extract real and imag parts:    re = real(Z);    im = imag(Z);    u_re = real(u_Z);    u_im = imag(u_Z);            % sqrt(re^2*u_re^2+im^2*u_im^2)/sqrt(re^2+im^2)):    %u_Z = sqrt(re.^2.*u_re.^2 + im.^2.*u_im.^2)./sqrt(re.^2 + im.^2);    u_Z = (re.^2.*u_re.^2 + im.^2.*u_im.^2).^0.5./(re.^2 + im.^2).^0.5;        % sqrt(im^2*u_re^2+re^2*u_im^2)/(re^2+im^2):    %u_phi = sqrt(im.^2.*u_re.^2 + re.^2.*u_im.^2)./(re.^2 + im.^2);    u_phi = (im.^2.*u_re.^2 + re.^2.*u_im.^2).^0.5./(re.^4 + 2*im.^2.*re.^2 + im.^4).^0.5;        % convert to polar:    phi = angle(Z);    Z = abs(Z); end% conversion of Cp-D scheme to complex Y scheme with uncertainty% note: it has been crippled by the bsxfun() for Matlab < 2016b - do not remove!function [Y,u_Y] = CpD2Y(f,Cp,D,u_Cp,u_D)     % nagular freq [rad/s]:    w = 2*pi*f;        % Y = w.*Cp.*(j + D) [S + jS]:    Y = bsxfun(@times,w,Cp).*(j + D);        % re: sqrt(Cp^2*u_D^2+D^2*u_Cp^2)*abs(w):    % im: abs(u_Cp)*abs(w):    u_Y = bsxfun(@times,sqrt(Cp.^2.*u_D.^2 + D.^2.*u_Cp.^2),w) + j*bsxfun(@times,u_Cp,w);end% conversion of Cp-Gp scheme to complex Y scheme with uncertainty% note: it has been crippled by the bsxfun() for Matlab < 2016b - do not remove!function [Y,u_Y] = CpGp2Y(f,Cp,Gp,u_Cp,u_Gp)     % angular freq [rad/s]:    w = 2*pi*f;        % admittance [S + jS]:    Y = Gp + j*bsxfun(@times,w,Cp);        % uncerainty [S + jS]:    u_Y = u_Gp + j*bsxfun(@times,w,u_Cp);end% conversion of Cp-Rp scheme to complex Z scheme with uncertainty% note: it has been crippled by the bsxfun() for Matlab < 2016b - do not remove!function [Z,u_Z] = CpRp2Z(f,Cp,Rp,u_Cp,u_Rp)     % nagular freq [rad/s]:    w = 2*pi*f;        % complex Z [Ohm + jOhm]:    Z = 1./(j*bsxfun(@times,Cp,w) + 1./Rp);            % uncertainty [Ohm + jOhm]:    re = sqrt(bsxfun(@times,Cp.^4.*Rp.^4.*u_Rp.^2 + 4*Cp.^2.*Rp.^6.*u_Cp.^2,w.^4) - 2*Cp.^2.*Rp.^2.*u_Rp.^2.*w.^2 + u_Rp.^2)./(bsxfun(@times,Cp.^4.*Rp.^4,w.^4) + bsxfun(@times,2*Cp.^2.*Rp.^2,w.^2) + 1);    im = (bsxfun(@times,Cp.^2.*Rp.^4.*u_Cp,w.^3) - bsxfun(@times,Rp.^2.*u_Cp,w))./(bsxfun(@times,Cp.^4.*Rp.^4,w.^4) + bsxfun(@times,2*Cp.^2.*Rp.^2,w.^2) + 1);    u_Z = re + j*im;    end% conversion of Ls-Rs scheme to complex Z scheme with uncertainty% note: it has been crippled by the bsxfun() for Matlab < 2016b - do not remove!function [Z,u_Z] = LsRs2Z(f,Ls,Rs,u_Ls,u_Rs)     % nagular freq [rad/s]:    w = 2*pi*f;        % Z = j*w*Ls + Rs [Ohm + jOhm]:    Z = j*bsxfun(@times,w,Ls) + Rs;        % re: abs(u_Rs)    % im: abs(u_Ls)*abs(w)    u_Z = u_Rs + j*bsxfun(@times,u_Ls,w);end% ======================================================================================% LOCAL COPY OF SOME TWM FUNCTIONS TO ENSURE THIS FUNCTION IS STANDALONE% ======================================================================================function [tbl] = correction_load_table(file,second_ax_name,quant_names)% TWM: Loader of the correction CSV file.%% This will load single CSV file of 1D or 2D dependence into structure.%% [tbl] = correction_load_table(file, second_ax_name, quant_names)% [tbl] = correction_load_table(file, second_ax_name, quant_names, i_mode)%% Parameters:%  file - full file path to the CSV file%       - may be replaced by cell array {quant. 1, quant. 2, ...},%         that will fake the CSV table with the values defined in the cells%         both axis of dependence will be empty. %  second_ax_name - if secondary CSV is 2D dependence, this is name of%                   of the variable to which the secondary axis values%                   will be placed.%  quant_names - names of the quantities in the CSV file%              - first one is always independent quantity (primary axis),%                following strings are names of the dependent quantities%  i_mode      - interpolation mode (default: 'linear')%% Returns:%  tbl.name - CSV file comment%  tbl.'quant_names{1}' - primary axis values%  tbl.'second_ax_name' - secondary axis values (optional)%  tbl.'quant_names{2}' - quantity 1 data%  ...%  tbl.'quant_names{N+1}' - quantity N data%  tbl.quant_names - names of the data quantities%  tbl.axis_x - name of the secondary axis quantity%  tbl.axis_y - name of the primary axis quantity%  tbl.has_x - secondary axis exist (even if it is empty)%  tbl.has_y - primary axis exist (even if it is empty)%  tbl.size_x - secondary axis size (0 when quantities independent on X)%  tbl.size_y - primary axis size (0 when quantities independent on Y)%%% Notes:% Missing quantity values in the middle of the data will be interpolated% per rows (linear mode by default).% Missing (empty) cells on the starting and ending rows will be replaced% by NaN.%% CSV format example (2D dependence):% My CSV title ;         ;         ;            ;%              ; Rs(Ohm) ; Rs(Ohm) ; u(Rs)(Ohm) ; u(Rs)(Ohm)% f(Hz)\U(V)   ; 0.1     ; 1.0     ; 0.1        ; 1.0% 0            ; 6.001   ; 6.002   ; 0.1        ; 0.1% 1000         ; 6.010   ; 6.012   ; 0.2        ; 0.2% 10000        ; 6.100   ; 6.102   ; 0.5        ; 0.5%% CSV format example (2D dependence, but independent on U axis):% My CSV title ;         ;           %              ; Rs(Ohm) ; u(Rs)(Ohm)% f(Hz)\U(V)   ;         ;        % 0            ; 6.001   ; 0.1       % 1000         ; 6.010   ; 0.2       % 10000        ; 6.100   ; 0.5       %% CSV format example (2D dependence, but independent on f axis):% My CSV title ;         ;         ;            ;%              ; Rs(Ohm) ; Rs(Ohm) ; u(Rs)(Ohm) ; u(Rs)(Ohm)% f(Hz)\U(V)   ; 0.1     ; 1.0     ; 0.1        ; 1.0%              ; 6.001   ; 6.002   ; 0.1        ; 0.1%% CSV format example (2D dependence, but independent on any axis):% My CSV title ;         ;           %              ; Rs(Ohm) ; u(Rs)(Ohm)% f(Hz)\U(V)   ;         ;        %              ; 6.001   ; 0.1       %% CSV format example (1D dependence):% My CSV title ;         ;         ;            ;% f(Hz)        ; Rs(Ohm) ; Rs(Ohm) ; u(Rs)(Ohm) ; u(Rs)(Ohm)% 0            ; 6.001   ; 6.002   ; 0.1        ; 0.1% 1000         ; 6.010   ; 6.012   ; 0.2        ; 0.2% 10000        ; 6.100   ; 6.102   ; 0.5        ; 0.5%%% This is part of the TWM - TracePQM WattMeter (https://github.com/smaslan/TWM).% (c) 2018, Stanislav Maslan, smaslan@cmi.cz% The script is distributed under MIT license, https://opensource.org/licenses/MIT.                %     % by default assume no secondary axis  if isempty(second_ax_name)    second_ax_name = '';    end    % identify interpolation mode:  if ~exist('i_mode','var')    i_mode = 'linear';  end    if iscell(file)    % default table        % which axes are there?    has_primary = ~isempty(quant_names{1});    has_second = ~isempty(second_ax_name);    % data quantities count    quant_N = numel(quant_names) - 1;        if numel(file) ~= quant_N + has_primary + has_second      error('Correction table loader: Number of data quantities does not match number of fake values to assign! Note the primary axis quantity is used even for faking table, so valid example is: quant_names = {''f'',''Rs'',''Xs''}, file = {[], 0, 0}.');    end        % fake table content    tbl.name = 'fake table';        fpos = 1;        % store primary axis    if has_primary      tbl = setfield(tbl,quant_names{1},file{fpos});      fpos = fpos + 1;    end    % store secondary axis    if has_second      tbl = setfield(tbl,second_ax_name,file{fpos});      fpos = fpos + 1;    end    % store quantities     for k = 1:quant_N      tbl = setfield(tbl,quant_names{k+1},file{fpos});      fpos = fpos + 1;    end             else      % try to load the table    csv = csv2cell(file,';');    [M,N] = size(csv);        % get rid of empty rows/columns    for m = M:-1:1      if ~all(cellfun(@isempty,csv(m,:)))        M = m;        break;      end    end      for n = N:-1:1      if ~all(cellfun(@isempty,csv(:,n)))        N = n;        break;      end    end        % check consistency of the table data and desired quantities count    Q = numel(quant_names);    if Q < 2      error('Correction table loader: not enough dependence quantities!');    end      if rem(N - 1,Q - 1)      error('Correction table loader: quantities count does not match size of the loaded table!');    end        % number of columns per quantity    A = round((N - 1)/(Q - 1));      if isempty(second_ax_name) && A > 1      error('Correction table loader: no secondary axis desired but correction data contain more than 1 column per quantity!');    end            % read name of the table    tbl.name = csv{1,1};        % initial row of correction data    d_row = 3;    if ~isempty(second_ax_name)      d_row = d_row + 1;    end          % load primary axis values    numz = cellfun(@isnumeric,csv(d_row:end,1)) & ~cellfun(@isempty,csv(d_row:end,1));    if any(numz) && ~all(numz)      error('Correction table loader: primary axis contains invalid cells!');    end    if numel(numz) == 1 && any(numz)      error('Correction table loader: primary axis contains invalid cells! There is just one row so there should not be primary axis value, just empty cell!');    elseif any(numz)      tbl = setfield(tbl,quant_names{1},cell2mat(csv(d_row:end,1)));    else      tbl = setfield(tbl,quant_names{1},[]);        end    prim = getfield(tbl,quant_names{1});        % load secondary axis values    if ~isempty(second_ax_name)      numz = cellfun(@isnumeric,csv(d_row-1,2:1+A)) & ~cellfun(@isempty,csv(d_row-1,2:1+A));      if any(numz) && ~all(numz)         error('Correction table loader: secondary axis contains invalid cells!');      end      if ~any(numz) && A > 1        error('Correction table loader: secondary axis contains invalid cells! There are multiple columns per quantity but not all have assigned secondary axis values.');      elseif any(numz) && A == 1        error('Correction table loader: secondary axis contains invalid cells! There is just on secondary axis item but it has nonzero value. It should be empty.');      elseif ~any(numz) || A == 1        tbl = setfield(tbl,second_ax_name,[]);      else          tbl = setfield(tbl,second_ax_name,cell2mat(csv(d_row-1,2:1+A)));      end    end        % --- for each quantity in the table    for q = 1:Q-1            % load csv portion with correction data      vv = csv(d_row:end,2+(q-1)*A:1+q*A);      R = size(vv,1);            % detect invalids      nanz = cellfun(@isempty,vv) | ~cellfun(@isnumeric,vv);            for a = 1:A                % get id of valid rows        vid = find(~nanz(:,a));        if ~numel(vid)          error('Correction table loader: no valid number in whole column???');          end                % build primary axis        if isempty(prim)          p = [];        else          p = prim(vid);        end        % build column        d = [vv{vid,a}].';          if numel(p) > 1          % interpolate data to fill in gaps and replace ends by NaNs               vv(1:end,a) = num2cell(interp1(p,d,prim,i_mode));        else          % just one row, cannot interpolate          tmp = vv(1:end,a);          vv(1:end,a) = NaN;          vv(vid,a) = tmp(vid);                         end              end                  % convert and store quantity to loaded table      tbl = setfield(tbl,quant_names{1+q},cell2mat(vv));              end      end    % store axes names  tbl.axis_x = second_ax_name;  tbl.has_x = ~isempty(tbl.axis_x);    if tbl.has_x    tbl.size_x = numel(getfield(tbl,second_ax_name));  else    tbl.size_x = 0;   end    tbl.axis_y = quant_names{1};  tbl.has_y = ~isempty(tbl.axis_y);  if tbl.has_y        tbl.size_y = numel(getfield(tbl,tbl.axis_y));  else    tbl.size_y = 0;  end    % store quantities names  tbl.quant_names = quant_names(2:end);endfunction [tout,ax,ay] = correction_expand_tables(tin,reduce_axes)% TWM: Expander of the correction tables loaded by 'correction_load_table'.%% This will take cell array of tables, looks for largest common range of % axes, then interpolates the tables data so all tables have the same axes.% It uses selected interpolation mode and no extrapolation. NaNs will be inserted% when range of new axis is outside range of source data.% Note it will repeat the process for all data quantities in the table.%% Example: x_axis_1 = [1 2 3 5], x_axis_2 = [3 4 6] will result in new axis:%          x_axis = [3 4 5]. The same for second axis.% If the table is independent to one or both axes, the function lets% them independent (will not create new axis).%% [tout,ax,xy] = correction_expand_tables(tin)% [tout,ax,xy] = correction_expand_tables(tin, reduce_axes)% [tout,ax,xy] = correction_expand_tables(..., i_mode)%% Parameters:%  tin         - cell array of input tables%  reduce_axes - reduces new axes to largest common range if set '1' (default)%                if set to '0', it will merge the source axes to largest%                needed range, but the data of some tables will contain NaNs!%  i_mode      - interpolation mode (default: 'linear')%                note: use 'none' to disable the interpolation - it will just find%                'ax','xy' and return unchanged tables%% Returns:%  tout - cell array of the modfied tables%  ax   - new x axis (empty if not exist)%  ay   - new y axis (empty if not exist) %%% This is part of the TWM - TracePQM WattMeter (https://github.com/smaslan/TWM).% (c) 2018, Stanislav Maslan, smaslan@cmi.cz% The script is distributed under MIT license, https://opensource.org/licenses/MIT.                %   % by default reduce axes to largest common range  if ~exist('reduce_axes','var')    reduce_axes = 1;  end    % identify interpolation mode:  if ~exist('i_mode','var')    if exist('reduce_axes','var') && ischar(reduce_axes)      i_mode = reduce_axes;    else      i_mode = 'linear';    end  end    % tables count  T = numel(tin);    % find unique x,y axis vlues for each table:  ax = [];  ay = [];  ax_min = [];  ax_max = [];  ay_min = [];  ay_max = [];  for t = 1:T    tab = tin{t};    if tab.size_x      xdata = getfield(tab,tab.axis_x);      ax = union(ax,xdata);      ax_min(end+1) = min(xdata);      ax_max(end+1) = max(xdata);       end    if tab.size_y      ydata = getfield(tab,tab.axis_y);      ay = union(ay,ydata);      ay_min(end+1) = min(ydata);      ay_max(end+1) = max(ydata);     end  end  % find largest common range of the axes:  ax_min = max(ax_min);  ax_max = min(ax_max);  ay_min = max(ay_min);  ay_max = min(ay_max);    if reduce_axes    % reduce output x,y axes ranges to largest common range:    ax = ax(ax >= ax_min & ax <= ax_max);    ay = ay(ay >= ay_min & ay <= ay_max);  end    % flip axes to right orientations:  ax = ax(:).';  ay = ay(:);    % new axes have some items?  has_x = ~~numel(ax);  has_y = ~~numel(ay);    % build meshgrid for 2D inetrpolation to the new axes:  if has_x && has_y    [axi,ayi] = meshgrid(ax,ay);  end    if strcmpi(i_mode,'none')    T = 0; % do not interpolate mode    tout = tin;  end    % --- now interpolate table data to new axes ---  for t = 1:T    % get one table:    tab = tin{t};        % get table's quantitites    qnames = tab.quant_names;    Q = numel(qnames);        % load current axes    if tab.size_x      xdata = getfield(tab,tab.axis_x);    end    if tab.size_y      ydata = getfield(tab,tab.axis_y);    end        % --- interpolate each quantity:    for q = 1:Q      if has_x && has_y && tab.size_x && tab.size_y        % table has both axes, interpolate in 2D                qu = getfield(tab,qnames{q});        qu = interp2nan(xdata,ydata,qu,axi,ayi,i_mode);        tab = setfield(tab,qnames{q},qu);      elseif has_y && tab.size_y        % only primary axis (Y), interpolate 1D        qu = getfield(tab,qnames{q});        qu = interp1nan(ydata,qu,ay,i_mode);                       tab = setfield(tab,qnames{q},qu);      elseif has_x && tab.size_x        % only secondary axis (X), interpolate 1D        qu = getfield(tab,qnames{q});        qu = interp1nan(xdata,qu,ax,i_mode);                tab = setfield(tab,qnames{q},qu);       end    end        % overwrite axes by new axes:    if tab.size_x      szx = numel(ax);      if szx > 1        tab = setfield(tab,tab.axis_x,ax);      else        tab = setfield(tab,tab.axis_x,[]);              end      tab.size_x = (szx > 1)*szx;            end    if tab.size_y      szy = numel(ay);      if szy > 1        tab = setfield(tab,tab.axis_y,ay);      else        tab = setfield(tab,tab.axis_y,[]);        tab.size_y = (szy > 1)*szy;      end            end        % return modified table table:    tout{t} = tab;      end    % delete axes with just one item:  if numel(ax) < 2    ax = [];  end  if numel(ay) < 2    ay = [];  endendfunction [tbl] = correction_interp_table(tbl,ax,ay,new_axis_name,new_axis_dim,i_mode)% TWM: Interpolator of the correction tables loaded by 'correction_load_table'.% It will return interpolated value(s) from the correction table either in 2D% mode or 1D mode.% % Usage:%   tbl = correction_interp_table(tbl, ax, [])%   tbl = correction_interp_table(tbl, [], ay)%   tbl = correction_interp_table(tbl, ax, ay)%   tbl = correction_interp_table(tbl, ax, ay, new_axis_name, new_axis_dim)%   tbl = correction_interp_table(..., i_mode)%%   tbl = correction_interp_table()%     - run self-test/validation%% Parameters:%   tbl           - Input table%   ax            - 1D vector of the new x-axis values (optional)%   ay            - 1D vector of the new y-axis values (optional)%   new_axis_name - If non-empty, the interpolation will be in 1D (optional)%                   in this case the 'ax' and 'ay' must have the same size%                   or one may be vector and one scalar, the scalar one will%                   be replicated to size of the other. The function will %                   return 1 item per item of 'ax'/'ay'%                   It will also create a new 1D table with the one axis name%                   'new_axis_name'.%   new_axis_dim  - In the 1D mode this defines which axis 'ax' or 'ay' will be%                   used for the new axis 'new_axis_name'.%   interp_mode   - Desired mode of interpolation same as for interp1(),%                   default is 'linear'.  %% note: leave 'ax' or 'ay' empty [] to not interpolate in that axis.% note: if the 'ax' or 'ay' is not empty and the table have not x or y% axis it will return an error.  %% Returns:%   tbl - table with interpolated quantities%% This is part of the TWM - TracePQM WattMeter.% (c) 2018, Stanislav Maslan, smaslan@cmi.cz% The script is distributed under MIT license, https://opensource.org/licenses/MIT.                %         % default parameters:    if ~exist('ax','var')        ax = [];    end    if ~exist('ay','var')        ay = [];    end    % desired axes to interpolate:    has_ax = ~isempty(ax);    has_ay = ~isempty(ay);        if has_ax && ~isvector(ax)        error('Correction table interpolator: Axis X is not a vector!');    end    if has_ay && ~isvector(ay)        error('Correction table interpolator: Axis Y is not a vector!');    end        % is it 2D interpolation?    in2d = ~(exist('new_axis_name','var') && exist('new_axis_dim','var'));        % input checking for the 2D mode    if ~in2d                if ~has_ax || ~has_ay             error('Correction table interpolator: 2D interpolation requsted, but some of the new axes is empty?');        end                if numel(ax) > 1 && numel(ay) > 1 && numel(ax) ~= numel(ay)            error('Correction table interpolator: Both axes must have the same items count or one must be scalar!');        end                % expand axes:        if isscalar(ay) && ~isvector(ax)            if new_axis_dim == 2                ay = repmat(ay,size(ax));            else                error('Correction table interpolator: Cannot expand axis ''ay'' because the ''new_axis_dim'' requests this axis as a new independnet axis of the table!');            end        elseif isscalar(ax) && ~isvector(ay)            if new_axis_dim == 1                ax = repmat(ax,size(ay));            else                error('Correction table interpolator: Cannot expand axis ''ax'' because the ''new_axis_dim'' requests this axis as a new independnet axis of the table!');            end                    end            elseif exist('new_axis_name','var')        % get interpolation mode:        i_mode = new_axis_name;    end        if ~exist('i_mode','var')        i_mode = 'linear'; % default interp mode    end        % check compatibility with data:    if has_ax && ~tbl.has_x        error('Correction table interpolator: Interpolation by nonexistent axis X required!');    end    if has_ay && ~tbl.has_y        error('Correction table interpolator: Interpolation by nonexistent axis Y required!');        end        % original independent axes data:    if tbl.has_x        ox = getfield(tbl,tbl.axis_x);    else        ox = [];    end    if tbl.has_y        oy = getfield(tbl,tbl.axis_y);    else        oy = [];    end            % if interpolation axis data 'ax' and/or 'ay' are not defined, return all table's elements in that axis/axes:     if isempty(ax)        ax = ox;    end    if isempty(ay)        ay = oy;    end        % count of the quantities in the table:    q_names = tbl.quant_names;    Q = numel(tbl.quant_names);        % load all quantities:    quants = {};    for q = 1:Q        quants{end+1} = getfield(tbl,q_names{q});    end        % flip axes to proper orientation:    ax = ax(:).';    ay = ay(:);        if ~in2d        % --- mode 1: one value per item of 'ax'/'ay':                    % interpolate each quantity:        if tbl.size_x && tbl.size_y            for q = 1:Q                quants{q} = interp2nan(ox,oy,quants{q},ax.',ay,i_mode);            end        elseif tbl.size_x            for q = 1:Q                quants{q} = interp1nan(ox,quants{q},ax,i_mode);            end        elseif tbl.size_y            for q = 1:Q                quants{q} = interp1nan(oy,quants{q},ay,i_mode);            end        else            if new_axis_dim == 1                for q = 1:Q                    quants{q} = repmat(quants{q},size(ay));                end            else                for q = 1:Q                    quants{q} = repmat(quants{q},size(ax));                end            end                    end                % set correct orientation:        if new_axis_dim == 1            for q = 1:Q                quants{q} = quants{q}(:);            end        else            for q = 1:Q                quants{q} = quants{q}(:).';            end            end                % --- modify the axes, because not it became just 1D table dependent on unknown new axis:                % remove original axes of the table:        tbl = rmfield(tbl,{tbl.axis_x, tbl.axis_y});        % create new axis:        if new_axis_dim == 1            % select 'ay' as the new axis:            tbl.axis_x = '';            tbl.axis_y = new_axis_name;            tbl.has_x = 0;            tbl.has_y = 1;        else            % select 'ax' as the new axis:            tbl.axis_x = new_axis_name;            tbl.axis_y = '';            tbl.has_x = 1;            tbl.has_y = 0;        end                else        % --- mode 2: regular 2D interpolation:                if ~isempty(ax) && ~isempty(ay)            if tbl.size_x && tbl.size_y                for q = 1:Q                    quants{q} = interp2nan(ox,oy,quants{q},ax,ay,i_mode);                end            elseif tbl.size_x                for q = 1:Q                    quants{q} = repmat(interp1nan(ox,quants{q},ax,i_mode),size(ay));                end            elseif tbl.size_y                for q = 1:Q                    quants{q} = repmat(interp1nan(oy,quants{q},ay,i_mode),size(ax));                end            else                for q = 1:Q                    quants{q} = repmat(quants{q},[numel(ay) numel(ax)]);                end            end                elseif ~isempty(ax)            if tbl.size_x                for q = 1:Q                    quants{q} = interp1nan(ox,quants{q},ax,i_mode);                end            else                for q = 1:Q                    quants{q} = repmat(quants{q},size(ax));                end            end                elseif ~isempty(ay)            if tbl.size_y                for q = 1:Q                    quants{q} = interp1nan(oy,quants{q},ay,i_mode);                end            else                for q = 1:Q                    quants{q} = repmat(quants{q},size(ay));                end            end                end     end          % store back the interpolated quantities:    for q = 1:Q        tbl = setfield(tbl,q_names{q},quants{q});    end            % set interpolated table's flags@stuff:    szx = size(quants{1},2)*(~~numel(quants{1}));    szy = size(quants{1},1)*(~~numel(quants{1}));        tbl.size_x = (szx > 1)*szx;    tbl.size_y = (szy > 1)*szy;    if ~tbl.has_x && tbl.size_x         tbl.axis_x = 'ax';        end    if ~tbl.has_y && tbl.size_y         tbl.axis_y = 'ay';        end        tbl.has_x = tbl.has_x | szx > 1;    tbl.has_y = tbl.has_y | szy > 1;        % store new x and y axis data:    if szx < 2        ax = [];    end    if szy < 2        ay = [];    end    if tbl.has_x         tbl = setfield(tbl,tbl.axis_x,ax);    end    if tbl.has_y        tbl = setfield(tbl,tbl.axis_y,ay);    endend% ====== SUB-FUNCTIONS SECTION ======function [yi] = interp1nan(x,y,xi,varargin)% This is a crude wrapper for interp1() function that should avoid unwanted NaN% results if the 'xi' is on the boundary of NaN data in 'y'.%% Note: Not all parameter combinations for interp1() are implemented!%       It is just very basic wrapper.%% Example:% x = [1 2 3], y = [1 2 NaN]% interp1(x,y,2,'linear') may return NaN because the 'xi = 2' is on the boundary% of the valid 'y' data.  %% This is part of the TWM - TracePQM WattMeter.% (c) 2018, Stanislav Maslan, smaslan@cmi.cz% The script is distributed under MIT license, https://opensource.org/licenses/MIT.                %     if any(isnan(y))        % maximum allowable tolerance:         max_eps = 5*eps*xi;                % try to interpolate with offsets xi = <xi +/- max_eps>:        tmp(:,:,1) = interp1(x,y,xi + max_eps,varargin{:});        tmp(:,:,2) = interp1(x,y,xi - max_eps,varargin{:});                % select non NaN results from the candidates:        yi = nanmean(tmp,3);            else        yi = interp1(x,y,xi,varargin{:});        end        endfunction [zi] = interp2nan(x,y,z,xi,yi,varargin)% This is a crude wrapper for interp2() function that should avoid unwanted NaN% results if the 'xi' or 'yi' is on the boundary of NaN data in 'z'.%% Note: Not all parameter combinations for interp2() are implemented!%       It is just very basic wrapper.%% Example:% x = [1 2 3]% y = [1;2;3]% z = [1 2 3;%      4 5 6;%      7 8 NaN]% interp2(x,y,z,3,2,'linear') may return NaN because the 'xi = 2' and 'yi = 3' % is on the boundary of the valid 'z' data.  %% This is part of the TWM - TracePQM WattMeter.% (c) 2018, Stanislav Maslan, smaslan@cmi.cz% The script is distributed under MIT license, https://opensource.org/licenses/MIT.                %     persistent is_octave;  % speeds up repeated calls      if isempty (is_octave)        is_octave = (exist ('OCTAVE_VERSION', 'builtin') > 0);    end    if any(isnan(z))            % maximum allowable tolerance:         max_eps_x = 5*eps*xi;        max_eps_y = 5*eps*yi;                if any(strcmpi(varargin,'linear')) || is_octave                % try to interpolate with offsets xi = <xi +/- max_eps>, yi = <yi +/- max_eps>:            tmp(:,:,1) = interp2(x,y,z,xi + max_eps_x,yi + max_eps_y,varargin{:});            tmp(:,:,2) = interp2(x,y,z,xi + max_eps_x,yi - max_eps_y,varargin{:});            tmp(:,:,3) = interp2(x,y,z,xi - max_eps_x,yi - max_eps_y,varargin{:});            tmp(:,:,4) = interp2(x,y,z,xi - max_eps_x,yi + max_eps_y,varargin{:});                else                    % try to interpolate with offsets xi = <xi +/- max_eps>, yi = <yi +/- max_eps>:            tmp(:,:,1) = interp2p(x,y,z,xi + max_eps_x,yi + max_eps_y,varargin{:});            tmp(:,:,2) = interp2p(x,y,z,xi + max_eps_x,yi - max_eps_y,varargin{:});            tmp(:,:,3) = interp2p(x,y,z,xi - max_eps_x,yi - max_eps_y,varargin{:});            tmp(:,:,4) = interp2p(x,y,z,xi - max_eps_x,yi + max_eps_y,varargin{:});                end              % select non NaN results from the candidates:        zi = nanmean(tmp,3);        else                if any(strcmpi(varargin,'linear')) || is_octave                zi = interp2(x,y,z,xi,yi,varargin{:});                else            zi = interp2p(x,y,z,xi,yi,varargin{:});        end    end    endfunction [zi] = interp2p(x,y,z,xi,yi,varargin)% very crude replacement of the interp2() to enable support for 'pchip' in 2D in Matlab% it is designed just for function in this file! Not general interp2 replacement!% note it was designed for long y-dim and short x-dim% when it is the other way, it will be painfully slow in Matlab         if sum(size(xi) > 1) > 1        % xi, yi are most likely meshes - reduce:        xi = xi(1,:);        yi = yi(:,1);    end        tmp = interp1(x.',z.',xi,varargin{:}).';        zi = interp1(y,tmp,yi,varargin{:});    %tmp = interp1(y,z,yi,varargin{:});    %zi = interp1(x.',tmp.',xi,varargin{:}).';end